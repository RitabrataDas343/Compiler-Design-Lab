The Sethi-Ullman algorithm is an algorithm used to optimize the code generated by a compiler by eliminating unnecessary operations and reducing the number of registers needed to hold intermediate values.

The given expression is:
{return 4*((2*5) ((6-2) +(49)));}

The algorithm starts by representing the expression as a tree, with the leaf nodes as operands and the internal nodes as operators.

The tree representation of the given expression is as follows:

        *
       / \
      /   \
     *     4
    / \
   /   \
  2     5
       / \
      +   *
     / \ / \
    -   6  2  9
   / \
  4   2

The algorithm then performs a bottom-up traversal of the tree, computing the values of the internal nodes in a left-to-right order.

Here is the process in more detail:

    First, we compute the value of the left subtree, where the left subtree is (6-2) which results in 4.
    Next, we compute the value of the right subtree, where the right subtree is (4*9) which results in 36.
    Next, we compute the value of the left subtree, where the left subtree is (4*36) which results in 144.
    Next, we compute the value of the root node, where the root node is (144*2) which results in 288.

So, the final optimized code is:

temp1 = 6-2;
temp2 = temp1 * 4;
temp3 = 4 * 9;
temp4 = temp2 + temp3;
temp5 = temp4 * 2;
result = temp5 * 4;
return result;

This code is using only sequential instructions and without branches and loops. All the intermediate values are stored in temporary variables, so the code doesn't depend on the order of operations, this is why the code doesn't need branches and loops.

The running time of the code is O(1) since it is a sequence of simple operations that are executed one after the other. The number of operations is constant, independent of the input size. The time complexity is not affected by the associativity and commutativity of the operators since the algorithm eliminates the need for branches and loops.